// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/vela-ssoc/ssoc-common/datalayer/model"
)

func newNotifier(db *gorm.DB, opts ...gen.DOOption) notifier {
	_notifier := notifier{}

	_notifier.notifierDo.UseDB(db, opts...)
	_notifier.notifierDo.UseModel(&model.Notifier{})

	tableName := _notifier.notifierDo.TableName()
	_notifier.ALL = field.NewAsterisk(tableName)
	_notifier.ID = field.NewInt64(tableName, "id")
	_notifier.Name = field.NewString(tableName, "name")
	_notifier.Events = field.NewField(tableName, "events")
	_notifier.Risks = field.NewField(tableName, "risks")
	_notifier.Ways = field.NewField(tableName, "ways")
	_notifier.Dong = field.NewString(tableName, "dong")
	_notifier.Email = field.NewString(tableName, "email")
	_notifier.Mobile = field.NewString(tableName, "mobile")
	_notifier.EventCode = field.NewBytes(tableName, "event_code")
	_notifier.RiskCode = field.NewBytes(tableName, "risk_code")

	_notifier.fillFieldMap()

	return _notifier
}

type notifier struct {
	notifierDo notifierDo

	ALL       field.Asterisk
	ID        field.Int64 // ID
	Name      field.String
	Events    field.Field
	Risks     field.Field
	Ways      field.Field
	Dong      field.String
	Email     field.String
	Mobile    field.String
	EventCode field.Bytes
	RiskCode  field.Bytes

	fieldMap map[string]field.Expr
}

func (n notifier) Table(newTableName string) *notifier {
	n.notifierDo.UseTable(newTableName)
	return n.updateTableName(newTableName)
}

func (n notifier) As(alias string) *notifier {
	n.notifierDo.DO = *(n.notifierDo.As(alias).(*gen.DO))
	return n.updateTableName(alias)
}

func (n *notifier) updateTableName(table string) *notifier {
	n.ALL = field.NewAsterisk(table)
	n.ID = field.NewInt64(table, "id")
	n.Name = field.NewString(table, "name")
	n.Events = field.NewField(table, "events")
	n.Risks = field.NewField(table, "risks")
	n.Ways = field.NewField(table, "ways")
	n.Dong = field.NewString(table, "dong")
	n.Email = field.NewString(table, "email")
	n.Mobile = field.NewString(table, "mobile")
	n.EventCode = field.NewBytes(table, "event_code")
	n.RiskCode = field.NewBytes(table, "risk_code")

	n.fillFieldMap()

	return n
}

func (n *notifier) WithContext(ctx context.Context) INotifierDo { return n.notifierDo.WithContext(ctx) }

func (n notifier) TableName() string { return n.notifierDo.TableName() }

func (n notifier) Alias() string { return n.notifierDo.Alias() }

func (n notifier) Columns(cols ...field.Expr) gen.Columns { return n.notifierDo.Columns(cols...) }

func (n *notifier) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := n.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (n *notifier) fillFieldMap() {
	n.fieldMap = make(map[string]field.Expr, 10)
	n.fieldMap["id"] = n.ID
	n.fieldMap["name"] = n.Name
	n.fieldMap["events"] = n.Events
	n.fieldMap["risks"] = n.Risks
	n.fieldMap["ways"] = n.Ways
	n.fieldMap["dong"] = n.Dong
	n.fieldMap["email"] = n.Email
	n.fieldMap["mobile"] = n.Mobile
	n.fieldMap["event_code"] = n.EventCode
	n.fieldMap["risk_code"] = n.RiskCode
}

func (n notifier) clone(db *gorm.DB) notifier {
	n.notifierDo.ReplaceConnPool(db.Statement.ConnPool)
	return n
}

func (n notifier) replaceDB(db *gorm.DB) notifier {
	n.notifierDo.ReplaceDB(db)
	return n
}

type notifierDo struct{ gen.DO }

type INotifierDo interface {
	gen.SubQuery
	Debug() INotifierDo
	WithContext(ctx context.Context) INotifierDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() INotifierDo
	WriteDB() INotifierDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) INotifierDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) INotifierDo
	Not(conds ...gen.Condition) INotifierDo
	Or(conds ...gen.Condition) INotifierDo
	Select(conds ...field.Expr) INotifierDo
	Where(conds ...gen.Condition) INotifierDo
	Order(conds ...field.Expr) INotifierDo
	Distinct(cols ...field.Expr) INotifierDo
	Omit(cols ...field.Expr) INotifierDo
	Join(table schema.Tabler, on ...field.Expr) INotifierDo
	LeftJoin(table schema.Tabler, on ...field.Expr) INotifierDo
	RightJoin(table schema.Tabler, on ...field.Expr) INotifierDo
	Group(cols ...field.Expr) INotifierDo
	Having(conds ...gen.Condition) INotifierDo
	Limit(limit int) INotifierDo
	Offset(offset int) INotifierDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) INotifierDo
	Unscoped() INotifierDo
	Create(values ...*model.Notifier) error
	CreateInBatches(values []*model.Notifier, batchSize int) error
	Save(values ...*model.Notifier) error
	First() (*model.Notifier, error)
	Take() (*model.Notifier, error)
	Last() (*model.Notifier, error)
	Find() ([]*model.Notifier, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Notifier, err error)
	FindInBatches(result *[]*model.Notifier, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Notifier) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) INotifierDo
	Assign(attrs ...field.AssignExpr) INotifierDo
	Joins(fields ...field.RelationField) INotifierDo
	Preload(fields ...field.RelationField) INotifierDo
	FirstOrInit() (*model.Notifier, error)
	FirstOrCreate() (*model.Notifier, error)
	FindByPage(offset int, limit int) (result []*model.Notifier, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) INotifierDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (n notifierDo) Debug() INotifierDo {
	return n.withDO(n.DO.Debug())
}

func (n notifierDo) WithContext(ctx context.Context) INotifierDo {
	return n.withDO(n.DO.WithContext(ctx))
}

func (n notifierDo) ReadDB() INotifierDo {
	return n.Clauses(dbresolver.Read)
}

func (n notifierDo) WriteDB() INotifierDo {
	return n.Clauses(dbresolver.Write)
}

func (n notifierDo) Session(config *gorm.Session) INotifierDo {
	return n.withDO(n.DO.Session(config))
}

func (n notifierDo) Clauses(conds ...clause.Expression) INotifierDo {
	return n.withDO(n.DO.Clauses(conds...))
}

func (n notifierDo) Returning(value interface{}, columns ...string) INotifierDo {
	return n.withDO(n.DO.Returning(value, columns...))
}

func (n notifierDo) Not(conds ...gen.Condition) INotifierDo {
	return n.withDO(n.DO.Not(conds...))
}

func (n notifierDo) Or(conds ...gen.Condition) INotifierDo {
	return n.withDO(n.DO.Or(conds...))
}

func (n notifierDo) Select(conds ...field.Expr) INotifierDo {
	return n.withDO(n.DO.Select(conds...))
}

func (n notifierDo) Where(conds ...gen.Condition) INotifierDo {
	return n.withDO(n.DO.Where(conds...))
}

func (n notifierDo) Order(conds ...field.Expr) INotifierDo {
	return n.withDO(n.DO.Order(conds...))
}

func (n notifierDo) Distinct(cols ...field.Expr) INotifierDo {
	return n.withDO(n.DO.Distinct(cols...))
}

func (n notifierDo) Omit(cols ...field.Expr) INotifierDo {
	return n.withDO(n.DO.Omit(cols...))
}

func (n notifierDo) Join(table schema.Tabler, on ...field.Expr) INotifierDo {
	return n.withDO(n.DO.Join(table, on...))
}

func (n notifierDo) LeftJoin(table schema.Tabler, on ...field.Expr) INotifierDo {
	return n.withDO(n.DO.LeftJoin(table, on...))
}

func (n notifierDo) RightJoin(table schema.Tabler, on ...field.Expr) INotifierDo {
	return n.withDO(n.DO.RightJoin(table, on...))
}

func (n notifierDo) Group(cols ...field.Expr) INotifierDo {
	return n.withDO(n.DO.Group(cols...))
}

func (n notifierDo) Having(conds ...gen.Condition) INotifierDo {
	return n.withDO(n.DO.Having(conds...))
}

func (n notifierDo) Limit(limit int) INotifierDo {
	return n.withDO(n.DO.Limit(limit))
}

func (n notifierDo) Offset(offset int) INotifierDo {
	return n.withDO(n.DO.Offset(offset))
}

func (n notifierDo) Scopes(funcs ...func(gen.Dao) gen.Dao) INotifierDo {
	return n.withDO(n.DO.Scopes(funcs...))
}

func (n notifierDo) Unscoped() INotifierDo {
	return n.withDO(n.DO.Unscoped())
}

func (n notifierDo) Create(values ...*model.Notifier) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Create(values)
}

func (n notifierDo) CreateInBatches(values []*model.Notifier, batchSize int) error {
	return n.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (n notifierDo) Save(values ...*model.Notifier) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Save(values)
}

func (n notifierDo) First() (*model.Notifier, error) {
	if result, err := n.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Notifier), nil
	}
}

func (n notifierDo) Take() (*model.Notifier, error) {
	if result, err := n.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Notifier), nil
	}
}

func (n notifierDo) Last() (*model.Notifier, error) {
	if result, err := n.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Notifier), nil
	}
}

func (n notifierDo) Find() ([]*model.Notifier, error) {
	result, err := n.DO.Find()
	return result.([]*model.Notifier), err
}

func (n notifierDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Notifier, err error) {
	buf := make([]*model.Notifier, 0, batchSize)
	err = n.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (n notifierDo) FindInBatches(result *[]*model.Notifier, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return n.DO.FindInBatches(result, batchSize, fc)
}

func (n notifierDo) Attrs(attrs ...field.AssignExpr) INotifierDo {
	return n.withDO(n.DO.Attrs(attrs...))
}

func (n notifierDo) Assign(attrs ...field.AssignExpr) INotifierDo {
	return n.withDO(n.DO.Assign(attrs...))
}

func (n notifierDo) Joins(fields ...field.RelationField) INotifierDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Joins(_f))
	}
	return &n
}

func (n notifierDo) Preload(fields ...field.RelationField) INotifierDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Preload(_f))
	}
	return &n
}

func (n notifierDo) FirstOrInit() (*model.Notifier, error) {
	if result, err := n.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Notifier), nil
	}
}

func (n notifierDo) FirstOrCreate() (*model.Notifier, error) {
	if result, err := n.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Notifier), nil
	}
}

func (n notifierDo) FindByPage(offset int, limit int) (result []*model.Notifier, count int64, err error) {
	result, err = n.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = n.Offset(-1).Limit(-1).Count()
	return
}

func (n notifierDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = n.Count()
	if err != nil {
		return
	}

	err = n.Offset(offset).Limit(limit).Scan(result)
	return
}

func (n notifierDo) Scan(result interface{}) (err error) {
	return n.DO.Scan(result)
}

func (n notifierDo) Delete(models ...*model.Notifier) (result gen.ResultInfo, err error) {
	return n.DO.Delete(models)
}

func (n *notifierDo) withDO(do gen.Dao) *notifierDo {
	n.DO = *do.(*gen.DO)
	return n
}
